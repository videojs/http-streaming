diff --git a/node_modules/qunit-retry/src/assert-result-handler.js b/node_modules/qunit-retry/src/assert-result-handler.js
index d988716..308b361 100644
--- a/node_modules/qunit-retry/src/assert-result-handler.js
+++ b/node_modules/qunit-retry/src/assert-result-handler.js
@@ -3,10 +3,31 @@ export default class AssertResultHandler {
     this.retry = retryObj
   }
 
+  async (target) {
+    return (count = 1) => {
+      let _count = 0;
+      let resolve;
+      target.async_ = new Promise((resolve_) => {
+        resolve = resolve_;
+      });
+
+      return () => {
+        _count++;
+
+        if (_count >= count) {
+          resolve();
+        }
+      }
+    }
+  }
+
   get (target, prop, receiver) {
     if (prop === 'pushResult') {
       return this.pushResultFn(target)
     }
+    if (prop === 'async') {
+      return this.async(target);
+    }
     return Reflect.get(target, prop, receiver)
   }
 
diff --git a/node_modules/qunit-retry/src/retry.js b/node_modules/qunit-retry/src/retry.js
index ac4cfaa..b03d2bc 100644
--- a/node_modules/qunit-retry/src/retry.js
+++ b/node_modules/qunit-retry/src/retry.js
@@ -1,16 +1,30 @@
 import AssertResultHandler from './assert-result-handler.js'
 
+const mapSeriesPromise = function(array, fn) {
+  const nextValue = array.shift();
+  const promise = fn(nextValue);
+
+  // if we still have array values left
+  // do the next one after this one
+  if (array.length) {
+    return promise.then(() => mapSeriesPromise(array, fn));
+  }
+
+  // this is the last promise
+  return promise;
+};
+
 export default class Retry {
-  constructor (name, callback, maxRuns, testFn) {
+  constructor (name, callback, maxRuns = 3, testFn) {
     this.name = name
     this.callback = callback
     this.maxRuns = maxRuns
     this.currentRun = 1
     this.assertResultHandler = new AssertResultHandler(this)
 
-    testFn(name, async (assert) => {
+    testFn(name, (assert) => {
       this.assertProxy = new Proxy(assert, this.assertResultHandler)
-      await this.retry(this.currentRun)
+      return this.retry(this.currentRun)
     })
   }
 
@@ -50,26 +64,41 @@ export default class Retry {
     return hooks.concat(module.hooks[handler])
   }
 
-  async runHooks (hooks) {
-    for (const hook of hooks) {
-      await hook.call(this.testEnvironment, this.assertProxy)
-    }
+  runHooks (hooks) {
+    return mapSeriesPromise(hooks, (hook) => {
+      return Promise.resolve(hook.call(this.testEnvironment, this.assertProxy));
+    });
   }
 
-  async runTest () {
-    if (this.notFirstRun) {
-      await this.runHooks(this.beforeEachHooks)
-    }
-    await this.tryTest()
-    // only run afterEach hooks if going to retry test
-    if (this.shouldRetry) {
-      await this.runHooks(this.afterEachHooks.reverse())
-    }
+  runTest () {
+    return Promise.resolve().then(() => {
+      if (this.notFirstRun) {
+        return this.runHooks(this.beforeEachHooks);
+      }
+      return Promise.resolve();
+    }).then(() => {
+      return this.tryTest()
+    }).then(() => {
+      // only run afterEach hooks if going to retry test
+      if (this.shouldRetry) {
+        return this.runHooks(this.afterEachHooks.reverse())
+      }
+
+      return Promise.resolve();
+    });
   }
 
-  async tryTest () {
+  tryTest () {
     try {
-      await this.callback.call(this.testEnvironment, this.assertProxy, this.currentRun)
+      return new Promise((resolve, reject) => {
+        const retval = this.callback.call(this.testEnvironment, this.assertProxy, this.currentRun)
+
+        if (this.assertProxy.async_) {
+          return resolve(this.assertProxy.async_);
+        }
+
+        resolve(retval)
+      });
     } catch (err) {
       if (!this.shouldRetry) {
         throw err
@@ -77,11 +106,14 @@ export default class Retry {
     }
   }
 
-  async retry () {
-    await this.runTest()
-    if (this.shouldRetry) {
-      this.currentRun++
-      await this.retry()
-    }
+  retry () {
+    return this.runTest().then(() => {
+      if (this.shouldRetry) {
+        this.currentRun++
+        return this.retry()
+      }
+
+      return Promise.resolve();
+    });
   }
 }
